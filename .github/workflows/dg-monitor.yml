name: DG Monitor 24x7 (Precision Final)

on:
  schedule:
    - cron: "*/5 * * * *"   # æ¯5åˆ†é’Ÿè¿è¡Œä¸€æ¬¡
  workflow_dispatch:

permissions:
  contents: write

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install playwright==1.46.0 opencv-python-headless numpy pillow requests pytz
          python -m playwright install --with-deps chromium

      - name: Write monitor.py (precision detection)
        shell: bash
        run: |
          cat > monitor.py << 'PY'
          # -*- coding: utf-8 -*-
          import os, time, json, traceback, statistics, math
          from datetime import datetime
          import pytz
          import requests
          import numpy as np
          import cv2
          from playwright.sync_api import sync_playwright

          # ============ å›ºå®šå‚æ•°ï¼ˆå·²å†™å…¥ä½ çš„å‡­æ®ï¼›å¦‚è®¾ç½®äº† Secrets ä¼šä¼˜å…ˆç”Ÿæ•ˆï¼‰ ============
          TG_TOKEN = os.getenv("TG_TOKEN") or "8134230045:AAH6C_H53R_J2RH98fGTqZFHsjkKALhsTh8"
          TG_CHAT_ID = os.getenv("TG_CHAT_ID") or "485427847"
          DG_URLS = ["https://dg18.co/wap/", "https://dg18.co/"]
          TZ = pytz.timezone("Asia/Kuala_Lumpur")
          STATE_FILE = "state.json"
          DEBUG_ANNOTATE = False   # å¦‚éœ€è°ƒè¯•å¯æ”¹ Trueï¼šä¼šåœ¨æ—¥å¿—ä¸­ä¿å­˜æ ‡æ³¨å›¾ï¼ˆä¸å‘å›¾ç»™TGï¼Œé¿å…æ‰“æ‰°ï¼‰

          # ============ å·¥å…·å‡½æ•° ============
          def now_ts_ms():
              return int(datetime.now(TZ).timestamp() * 1000)

          def send_tg(text: str):
              try:
                  requests.post(
                      f"https://api.telegram.org/bot{TG_TOKEN}/sendMessage",
                      data={"chat_id": TG_CHAT_ID, "text": text, "parse_mode": "HTML"},
                      timeout=20,
                  )
              except Exception:
                  pass

          def send_tg_photo(img_path: str, caption: str = ""):
              try:
                  with open(img_path, "rb") as f:
                      requests.post(
                          f"https://api.telegram.org/bot{TG_TOKEN}/sendPhoto",
                          data={"chat_id": TG_CHAT_ID, "caption": caption},
                          files={"photo": f},
                          timeout=30,
                      )
              except Exception:
                  pass

          def load_state():
              if os.path.exists(STATE_FILE):
                  try:
                      return json.load(open(STATE_FILE, "r", encoding="utf-8"))
                  except Exception:
                      return {}
              return {}

          def save_state(st):
              with open(STATE_FILE, "w", encoding="utf-8") as f:
                  json.dump(st, f, ensure_ascii=False, indent=2)

          # ============ å›¾åƒå¤„ç†ï¼šæå–çº¢/è“åœ†ç‚¹ ============
          def bgr_from_bytes(b: bytes):
              arr = np.frombuffer(b, np.uint8)
              return cv2.imdecode(arr, cv2.IMREAD_COLOR)

          def detect_colored_circles(bgr):
              """åŒé€šé“ï¼šHSV é˜ˆå€¼ + éœå¤«åœ†ï¼Œå†ç”¨è½®å»“å…œåº•ã€‚è¿”å› red_pts/blue_pts åˆ—è¡¨[(x,y),...]"""
              hsv = cv2.cvtColor(bgr, cv2.COLOR_BGR2HSV)

              # çº¢è‰²èŒƒå›´ï¼ˆä¸¤æ®µï¼‰
              lower_red1 = np.array([0, 70, 70]);   upper_red1 = np.array([10, 255, 255])
              lower_red2 = np.array([160, 70, 70]); upper_red2 = np.array([180, 255, 255])
              mask_r = cv2.bitwise_or(cv2.inRange(hsv, lower_red1, upper_red1),
                                      cv2.inRange(hsv, lower_red2, upper_red2))
              # è“è‰²èŒƒå›´
              lower_blue = np.array([90, 50, 50]);  upper_blue = np.array([140, 255, 255])
              mask_b = cv2.inRange(hsv, lower_blue, upper_blue)

              def hough_and_contour(mask):
                  mask = cv2.medianBlur(mask, 5)
                  # è‡ªé€‚åº”åŠå¾„èŒƒå›´ï¼ˆæŒ‰å›¾å¤§å°ï¼‰
                  h, w = mask.shape[:2]
                  minR = max(3, int(min(h, w) * 0.008))
                  maxR = max(minR+2, int(min(h, w) * 0.03))
                  # éœå¤«åœ†
                  circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, dp=1.2, minDist=max(6, minR*2),
                                             param1=80, param2=12, minRadius=minR, maxRadius=maxR)
                  pts = []
                  if circles is not None:
                      for c in np.uint16(np.around(circles[0, :])):
                          pts.append((int(c[0]), int(c[1])))
                  # è½®å»“å…œåº•
                  cnts, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                  for cnt in cnts:
                      (x, y), r = cv2.minEnclosingCircle(cnt)
                      area = cv2.contourArea(cnt)
                      if area <= 0: continue
                      circ = (4*math.pi*area) / (cv2.arcLength(cnt, True)**2 + 1e-6)
                      if 0.3 < circ <= 1.2 and minR*minR*math.pi*0.4 <= area <= maxR*maxR*math.pi*1.8:
                          pts.append((int(x), int(y)))
                  # å»é‡
                  uniq = []
                  for p in pts:
                      if all((abs(p[0]-q[0])>4 or abs(p[1]-q[1])>4) for q in uniq):
                          uniq.append(p)
                  return uniq

              red_pts  = hough_and_contour(mask_r)
              blue_pts = hough_and_contour(mask_b)
              return red_pts, blue_pts

          # ============ åˆ—èšç±» & è¿ç»­ç»Ÿè®¡ ============
          def cluster_columns(points, x_tol=None):
              if not points: return []
              pts = sorted(points, key=lambda p: p[0])
              xs = [p[0] for p in pts]
              diffs = [xs[i+1]-xs[i] for i in range(len(xs)-1)] if len(xs)>1 else [16]
              cell_w = max(8, int(statistics.median(diffs)))  # ä¼°è®¡æ¯åˆ—é—´è·
              tol = x_tol or max(8, int(cell_w*0.6))
              cols = [[pts[0]]]
              for p in pts[1:]:
                  if abs(p[0]-cols[-1][-1][0]) <= tol:
                      cols[-1].append(p)
                  else:
                      cols.append([p])
              for c in cols:
                  c.sort(key=lambda p: p[1])  # æŒ‰ y ä»ä¸Šåˆ°ä¸‹
              return cols

          def longest_run_in_col(col_pts):
              """ä¼°ç®—åŒåˆ—æœ€å¤§â€˜ä»ä¸Šåˆ°ä¸‹â€™å¯æ•°çš„ç²’æ•°ï¼Œå¿½ç•¥æå° y é—´è·çš„é‡å ç‚¹"""
              if not col_pts: return 0
              ys = [p[1] for p in col_pts]
              runs = 1; best = 1
              # è‡ªé€‚åº”æœ€å°æ­¥è¿›ï¼ˆè¿‡æ»¤é‡å ç”»ç¬”ï¼‰
              gaps = [ys[i+1]-ys[i] for i in range(len(ys)-1)]
              step = max(5, int(statistics.median(gaps)) if gaps else 10)
              for i in range(1, len(ys)):
                  if ys[i] - ys[i-1] >= step:
                      runs += 1
                      best = max(best, runs)
              return best

          def has_duolian_adjacent(color_cols):
              """ç›¸é‚»ä¸¤åˆ—åŒè‰² & ä¸¤åˆ—å„è‡ªæœ€é•¿â‰¥4  => â€˜å¤šè¿/è¿ç â€™"""
              if len(color_cols) < 2: return False
              # æŒ‰ x æ’åº
              cols_sorted = sorted(color_cols, key=lambda col: sum(p[0] for p in col)/len(col))
              for i in range(len(cols_sorted)-1):
                  if longest_run_in_col(cols_sorted[i]) >= 4 and longest_run_in_col(cols_sorted[i+1]) >= 4:
                      return True
              return False

          def analyze_table(bgr, idx=0):
              """å¯¹å•å¼ æ¡Œé¢å›¾åƒï¼ˆcanvasæˆ–æ•´é¡µæˆªå±ï¼‰åšç»Ÿè®¡"""
              red_pts, blue_pts = detect_colored_circles(bgr)
              marker_count = len(red_pts)+len(blue_pts)
              # æ²¡ç‚¹æˆ–ç‚¹å¤ªå°‘çš„å›¾ï¼Œè§†ä¸ºéæ¡Œé¢/æ— æ•ˆ
              if marker_count < 15:
                  return None

              red_cols  = cluster_columns(red_pts)
              blue_cols = cluster_columns(blue_pts)
              all_cols  = cluster_columns(red_pts+blue_pts)

              # å„ç±»åˆ¤æ–­
              long4_R = [c for c in red_cols  if longest_run_in_col(c) >= 4]
              long4_B = [c for c in blue_cols if longest_run_in_col(c) >= 4]

              long8_R  = any(longest_run_in_col(c) >= 8  for c in red_cols)
              long8_B  = any(longest_run_in_col(c) >= 8  for c in blue_cols)
              long10_R = any(longest_run_in_col(c) >= 10 for c in red_cols)
              long10_B = any(longest_run_in_col(c) >= 10 for c in blue_cols)

              has_long4  = (len(long4_R)+len(long4_B)) > 0
              has_long8  = (long8_R or long8_B)
              has_long10 = (long10_R or long10_B)
              has_duo    = has_duolian_adjacent(red_cols) or has_duolian_adjacent(blue_cols)

              # å•è·³æ¯”ä¾‹ï¼šæŠŠæ‰€æœ‰åˆ—çš„æœ€é•¿è¿æ•°<=1 è§†ä¸ºå•è·³åˆ—
              if all_cols:
                  single_cols = sum(1 for c in all_cols if longest_run_in_col(c) <= 1)
                  single_ratio = single_cols/len(all_cols)
              else:
                  single_ratio = 1.0

              # è°ƒè¯•æ ‡æ³¨ï¼ˆå¯é€‰ï¼‰
              if DEBUG_ANNOTATE:
                  dbg = bgr.copy()
                  for x,y in red_pts:  cv2.circle(dbg,(x,y),6,(0,0,255),2)
                  for x,y in blue_pts: cv2.circle(dbg,(x,y),6,(255,0,0),2)
                  cv2.putText(dbg,f"L4:{has_long4} L8:{has_long8} L10:{has_long10} Duo:{has_duo}",(10,26),
                              cv2.FONT_HERSHEY_SIMPLEX,0.7,(0,255,0),2)
                  cv2.imwrite(f"annot_table_{idx}.png", dbg)

              return {
                  "has_long4": has_long4,
                  "has_long8": has_long8,
                  "has_long10": has_long10,
                  "has_duolian": has_duo,
                  "single_ratio": float(single_ratio),
                  "marker_count": int(marker_count),
              }

          # ============ æµè§ˆå™¨ï¼šè¿›å…¥ DG å¹¶æŠ“å–ç”»é¢ ============
          def try_enter_and_capture():
              imgs = []
              with sync_playwright() as p:
                  browser = p.chromium.launch(headless=True, args=[
                      "--disable-blink-features=AutomationControlled",
                      "--no-sandbox",
                      "--disable-gpu"
                  ])
                  ctx = browser.new_context(viewport={"width": 1280, "height": 2600})
                  page = ctx.new_page()
                  try:
                      for url in DG_URLS:
                          try:
                              page.goto(url, timeout=30000)
                              # ç‚¹å‡»â€œå…è´¹è¯•ç© / Freeâ€
                              clicked = False
                              for sel in ["text=å…è´¹è¯•ç©", "text=Free", "button:has-text('å…è´¹è¯•ç©')", "a:has-text('å…è´¹è¯•ç©')", "text=FREE", "text=free"]:
                                  try:
                                      page.click(sel, timeout=2500)
                                      clicked = True
                                      break
                                  except Exception:
                                      continue
                              # å¯èƒ½æ–°å¼€é¡µ
                              time.sleep(1.0)
                              if len(ctx.pages) > 1:
                                  page = ctx.pages[-1]

                              # ç­‰å¾…é¡µé¢èµ„æºåŠ è½½ & æ»šåŠ¨åŠ è½½
                              page.wait_for_load_state("networkidle", timeout=20000)
                              for _ in range(6):
                                  page.mouse.wheel(0, 600); time.sleep(0.25)

                              # å°è¯•æŠ“å– canvasï¼ˆå¤§å¤šæ•°è·¯å•åœ¨ canvasï¼‰
                              canvases = page.query_selector_all("canvas")
                              for i, c in enumerate(canvases):
                                  try:
                                      box = c.bounding_box()
                                      if not box: continue
                                      if 90 <= box["width"] <= 1000 and 60 <= box["height"] <= 700:
                                          imgs.append(c.screenshot())
                                  except Exception:
                                      continue

                              # å…œåº•ï¼šæ•´é¡µæˆªå›¾ï¼ˆç”¨äºæŸäº›ç»ˆç«¯å¸ƒå±€ï¼‰
                              if not imgs:
                                  imgs.append(page.screenshot(full_page=True))

                              if imgs:
                                  break
                          except Exception:
                              continue
                  finally:
                      browser.close()
              return imgs

          # ============ å±€åŠ¿åˆ†ç±»ï¼ˆä¸¥æ ¼æŒ‰ä½ ç»™çš„é˜ˆå€¼ï¼‰ ============
          def classify_all(stats):
              # è¿‡æ»¤æ— æ•ˆæ¡Œï¼ˆæ ‡è®°ç‚¹å¤ªå°‘çš„ï¼‰
              stats = [s for s in stats if s and s["marker_count"] >= 15]
              n = len(stats)
              if n == 0:
                  return "NO_DATA", {"tables": 0}

              long4_tables  = sum(1 for s in stats if s["has_long4"] and s["single_ratio"] < 0.7)
              long8_tables  = sum(1 for s in stats if s["has_long8"])
              long10_tables = sum(1 for s in stats if s["has_long10"])
              duolian_tables= sum(1 for s in stats if s["has_duolian"])
              single_heavy  = sum(1 for s in stats if s["single_ratio"] >= 0.7)

              # è§„åˆ™ï¼šè¶…é•¿é¾™ + è‡³å°‘ä¸¤å¼ é•¿é¾™ï¼ˆæ€»â‰¥3å¼ ï¼‰ä¹Ÿç®—æ”¾æ°´
              trigger_super = (long10_tables >= 1 and (long8_tables + long10_tables) >= 3)

              # æ”¾æ°´æ—¶æ®µï¼ˆæé«˜èƒœç‡ï¼‰
              cond_full = (n >= 20 and long4_tables >= 8) or (10 <= n < 20 and long4_tables >= 4) or trigger_super

              # ä¸­ç­‰èƒœç‡ï¼ˆä¸­ä¸Šï¼‰
              cond_mid_up = False
              if ((n >= 20 and long4_tables >= 6) or (10 <= n < 20 and long4_tables >= 3)) \
                 and ((long8_tables + long10_tables) >= 2) and (duolian_tables >= 1):
                  cond_mid_up = True

              # æ”¶å‰²ï¼ˆä¸æé†’ï¼‰ï¼šé•¿é¾™<2 ä¸” å•è·³æ³›æ»¥
              cond_harvest = (long8_tables + long10_tables) < 2 and single_heavy >= max(3, int(0.5*n))

              detail = {
                  "tables": n,
                  "long4_tables": long4_tables,
                  "long8_tables": long8_tables,
                  "long10_tables": long10_tables,
                  "duolian_tables": duolian_tables,
                  "single_heavy": single_heavy,
                  "trigger_super": trigger_super,
              }

              if cond_full:   return "FANGSHUI", detail
              if cond_mid_up: return "MID_UP", detail
              if cond_harvest:return "HARVEST", detail
              return "MID", detail

          # ============ è¿è¡Œä¸»æµç¨‹ ============
          def main():
              st = load_state()
              try:
                  raw_imgs = try_enter_and_capture()
                  if not raw_imgs:
                      send_tg("âš ï¸ æ£€æµ‹å¤±è´¥ï¼šæœªæˆªåˆ°æ¡Œé¢ç”»é¢ï¼ˆå¯èƒ½éœ€æ»‘å—æˆ–é¡µé¢ç»“æ„å˜åŒ–ï¼‰ã€‚")
                      return

                  stats = []
                  for i, b in enumerate(raw_imgs):
                      bgr = bgr_from_bytes(b)
                      s = analyze_table(bgr, idx=i)
                      if s: stats.append(s)

                  status, d = classify_all(stats)
                  now_str = datetime.now(TZ).strftime("%Y-%m-%d %H:%M")
                  if status == "NO_DATA":
                      send_tg(f"{now_str}ï¼ˆé©¬æ¥è¥¿äºšæ—¶é—´ï¼‰\nâš ï¸ æœªè·å–æœ‰æ•ˆæ¡Œé¢æ•°æ®ï¼Œè¯·ç¨åå†è¯•ã€‚")
                      return

                  # ç»„è£…ç®€æŠ¥
                  brief = (
                      f"æ¡Œæ•°:{d['tables']} | é•¿è¿â‰¥4:{d.get('long4_tables',0)} | "
                      f"é•¿é¾™â‰¥8:{d.get('long8_tables',0)} | è¶…é•¿é¾™â‰¥10:{d.get('long10_tables',0)} | "
                      f"å¤šè¿/è¿ç :{d.get('duolian_tables',0)}"
                  )

                  last_status = st.get("status")
                  active_since = st.get("active_since")

                  # æ”¾æ°´ä¸ä¸­ä¸Šï¼šæé†’
                  if status in ("FANGSHUI","MID_UP"):
                      if last_status not in ("FANGSHUI","MID_UP"):
                          st["active_since"] = now_ts_ms()
                          st["active_type"] = status
                          send_tg(
                              f"{now_str}ï¼ˆé©¬æ¥è¥¿äºšæ—¶é—´ï¼‰\n"
                              f"âœ… {'æ”¾æ°´æ—¶æ®µï¼ˆæé«˜èƒœç‡ï¼‰' if status=='FANGSHUI' else 'ä¸­ç­‰èƒœç‡ï¼ˆä¸­ä¸Šï¼‰'} å·²å¼€å§‹\n{brief}"
                          )
                      else:
                          # æ­£å¤„äºæ”¾æ°´/ä¸­ä¸Šï¼Œä¸é‡å¤åˆ·å±
                          pass
                  else:
                      # éæ”¾æ°´æ€
                      if last_status in ("FANGSHUI","MID_UP") and active_since:
                          dur_min = max(1, int((now_ts_ms()-active_since)/60000))
                          send_tg(
                              f"{now_str}ï¼ˆé©¬æ¥è¥¿äºšæ—¶é—´ï¼‰\n"
                              f"ğŸ”” æ”¾æ°´å·²ç»“æŸï¼Œå…±æŒç»­ {dur_min} åˆ†é’Ÿã€‚\n{brief}"
                          )
                          st["active_since"] = None
                          st["active_type"] = None
                      else:
                          # å¿ƒè·³
                          send_tg(f"{now_str}ï¼ˆé©¬æ¥è¥¿äºšæ—¶é—´ï¼‰\nâ„¹ï¸ æ£€æµ‹å®Œæˆï¼šç›®å‰æ— æ”¾æ°´è¿¹è±¡ã€‚\n{brief}")

                  st["status"] = status
                  save_state(st)

              except Exception as e:
                  err = f"{e}\n{traceback.format_exc()}"
                  open("last_error.txt","w",encoding="utf-8").write(err)
                  send_tg(f"âš ï¸ è„šæœ¬å¼‚å¸¸ï¼š{str(e)[:700]}")

          if __name__ == "__main__":
              main()
          PY

      - name: Run monitor
        env:
          TG_TOKEN: ${{ secrets.TG_TOKEN }}
          TG_CHAT_ID: ${{ secrets.TG_CHAT_ID }}
        run: |
          python monitor.py

      - name: Persist state (store status & history)
        run: |
          if [ -n "$(git status --porcelain)" ]; then
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add -A
            git commit -m "update state [skip ci]"
            git push
          fi
