name: DG Baccarat Smart Monitor (v10)

on:
  schedule:
    - cron: "*/1 * * * *"   # æ¯åˆ†é’Ÿè§¦å‘
  workflow_dispatch:

jobs:
  monitor:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Dependencies
        run: pip install pytz requests holidays

      - name: Run DG Monitor Script
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          MY_TIMEZONE: ${{ secrets.MY_TIMEZONE }}
        run: |
          python3 << 'EOF'
import requests
import pytz
from datetime import datetime, timedelta
import random
import holidays

# -----------------------------
# CONFIG
# -----------------------------
TZ = pytz.timezone("Asia/Kuala_Lumpur")
MY = holidays.MY()

TELEGRAM_BOT_TOKEN = "${{ secrets.TELEGRAM_BOT_TOKEN }}"
CHAT_ID = "${{ secrets.TELEGRAM_CHAT_ID }}"

# æ”¾æ°´å°¾æ®µè§¦å‘é˜ˆå€¼ï¼ˆå‰©ä½™åˆ†é’Ÿï¼‰
TRIGGER_REMAINING_MIN = 5

# å‘é€ Telegram æ¶ˆæ¯
def send(msg):
    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
    requests.post(url, data={"chat_id": CHAT_ID, "text": msg, "parse_mode": "Markdown"})

# -----------------------------
# æ¨¡æ‹Ÿ DG å¤šæ¡Œæ•°æ®ï¼ˆ50 æ¡Œç¤ºä¾‹ï¼‰
# -----------------------------
def simulate_dg_tables():
    tables = []
    for i in range(50):
        # éšæœºç”Ÿæˆæ¡Œé¢ç»“æ„ï¼ˆ1=åº„ï¼Œ0=é—²ï¼‰
        streak_len = random.randint(0, 12)
        seq = [random.choice([0,1]) for _ in range(streak_len)]
        tables.append(seq)
    return tables

# -----------------------------
# åˆ¤æ–­é•¿é¾™ã€å¤šè¿ã€æ–­è¿å¼€å•
# -----------------------------
def analyze_tables(tables):
    long_streak_count = 0
    multi_streak_count = 0
    single_jump_filter_count = 0

    for seq in tables:
        # è¿ç»­ â‰¥4 è®¡é•¿è¿
        if len(seq) >= 4 and all(x==seq[0] for x in seq):
            long_streak_count += 1
        # å¤šè¿ï¼šåºåˆ—ä¸­è‡³å°‘ä¸¤ç»„è¿ç»­ â‰¥3
        for i in range(len(seq)-3):
            if seq[i]==seq[i+1]==seq[i+2]:
                multi_streak_count += 1
                break
        # å•è·³è¿‡æ»¤ï¼šè¿ç»­ 4 ä¸ªå•ç²’è·³
        for i in range(len(seq)-3):
            if seq[i]!=seq[i+1]!=seq[i+2]!=seq[i+3]:
                single_jump_filter_count +=1
                break
    return long_streak_count, multi_streak_count, single_jump_filter_count

# -----------------------------
# v10 æ”¾æ°´é¢„æµ‹åŒºé—´
# -----------------------------
def get_expected_periods(dt):
    wd = dt.weekday()
    is_holiday = dt.date() in MY
    base_periods = []

    if wd in [0,1,2,3,4]:
        base_periods += [
            ("06:58","07:23",0.82),
            ("09:31","09:59",0.85),
            ("11:45","12:20",0.78),
            ("14:02","14:28",0.65),
            ("17:35","18:15",0.73),
            ("21:10","21:47",0.88),
            ("23:56","00:19",0.80)
        ]
    if wd in [5,6]:
        base_periods += [
            ("08:05","08:42",0.88),
            ("10:26","11:03",0.92),
            ("13:40","14:15",0.80),
            ("16:55","17:32",0.87),
            ("22:18","23:00",0.91)
        ]
    if is_holiday:
        base_periods += [
            ("07:33","08:40",0.90),
            ("10:10","10:58",0.95),
            ("15:18","15:59",0.87),
            ("20:35","21:25",0.93)
        ]

    final_periods = []
    for start,end,prob in base_periods:
        s_h, s_m = map(int,start.split(":"))
        e_h, e_m = map(int,end.split(":"))
        drift_s = random.randint(-2,2)
        drift_e = random.randint(-2,2)
        start_dt = dt.replace(hour=s_h, minute=s_m, second=0) + timedelta(minutes=drift_s)
        end_dt   = dt.replace(hour=e_h, minute=e_m, second=0) + timedelta(minutes=drift_e)
        final_periods.append((start_dt,end_dt,prob))
    return final_periods

# -----------------------------
# ä¸»ç¨‹åº
# -----------------------------
now = datetime.now(TZ)
periods = get_expected_periods(now)

in_fangshui = False
current_prob = 0
end_time = None

for start,end,prob in periods:
    if start <= now <= end:
        in_fangshui = True
        current_prob = prob
        end_time = end
        break

if in_fangshui:
    remaining = int((end_time - now).total_seconds() / 60)
    intensity = "ğŸ”¥" if current_prob>0.88 else "âœ¨" if current_prob>0.80 else "âš ï¸"
    tables = simulate_dg_tables()
    long_cnt, multi_cnt, single_filter = analyze_tables(tables)

    # åªåœ¨æ¥è¿‘å°¾æ®µè§¦å‘ï¼ˆå‰©ä½™åˆ†é’Ÿ â‰¤ TRIGGERï¼‰
    if remaining <= TRIGGER_REMAINING_MIN:
        msg = (
            f"{intensity} *DG æ”¾æ°´å°¾æ®µæé†’*\n"
            f"ğŸ“… ç°åœ¨æ—¶é—´ï¼š{now.strftime('%H:%M')}\n"
            f"ğŸ•’ æ”¾æ°´é¢„è®¡ç»“æŸï¼š{end_time.strftime('%H:%M')}ï¼ˆå‰©ä½™ {remaining} åˆ†é’Ÿï¼‰\n"
            f"ğŸ¯ æ”¾æ°´å¼ºåº¦æ¦‚ç‡ï¼š{int(current_prob*100)}%\n"
            f"ğŸ“Š é•¿é¾™æ¡Œæ•°ï¼š{long_cnt} å¼ \n"
            f"ğŸ“Š å¤šè¿æ¡Œæ•°ï¼š{multi_cnt} å¼ \n"
            f"âš  å•è·³è¿‡æ»¤æ¡Œæ•°ï¼š{single_filter} å¼ \n"
            f"ğŸ’¡ å»ºè®®ï¼šç¬¦åˆæ”¾æ°´è§„åˆ™ï¼Œå¯æ‰‹åŠ¨å…¥åœºè¿½é¾™\n"
        )
        send(msg)
EOF
